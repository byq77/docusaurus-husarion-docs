<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Creating nodes · Husarion Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;workspace-setup&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#workspace-setup&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Workspace setup&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Creating nodes · Husarion Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://byq77.github.io/docusaurus-husarion-docs/index.html"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;workspace-setup&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#workspace-setup&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Workspace setup&lt;/h2&gt;
"/><meta property="og:image" content="https://byq77.github.io/docusaurus-husarion-docs/img/favicon.ico"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://byq77.github.io/docusaurus-husarion-docs/img/favicon.ico"/><link rel="shortcut icon" href="/docusaurus-husarion-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css"/><script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://byq77.github.io/docusaurus-husarion-docs/js/scrollspy.js"></script><script type="text/javascript" src="https://byq77.github.io/docusaurus-husarion-docs/js/sidebarScroll.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"diameter":56,"cornerOffset":20,"backgroundColor":"#d0112b","textColor":"#fff"}
          )
        });
        </script><link rel="stylesheet" href="/docusaurus-husarion-docs/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docusaurus-husarion-docs/"><h2 class="headerTitle">Husarion Docs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docusaurus-husarion-docs/docs/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/docusaurus-husarion-docs/docs/manuals/" target="_self">Manuals</a></li><li class=""><a href="/docusaurus-husarion-docs/docs/software/hframework" target="_self">Software</a></li><li class=""><a href="https://husarion.com/downloads/" target="_blank">Downloads</a></li><li class=""><a href="https://community.husarion.com/" target="_blank">Community</a></li><li class=""><a href="https://cloud.husarion.com/" target="_blank">Log In</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Tutorials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/">About tutorials</a></li><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">How to start</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/run-your-first-program">1. Run your first program</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/video-streaming-from-a-camera">2. Video streaming</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/getting-started-with-husarion--lego-mindstorms">3. Getting started with Husarion + LEGO Mindstorms</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/telepresence-robot-kit---quick-start">4. Telepresence robot kit - quick start</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/using-third-party-modules">5. Using third-party modules</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/rosbot---quick-start">6. ROSbot - quick start</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ROS tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/1-ros-introduction">1. ROS introduction</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/2-creating-nodes">2. Creating nodes</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/3-simple-kinematics-for-mobile-robot">3. Simple kinematics for mobile robot</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/4-visual-object-recognition">4. Visual object recognition</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/5-running-ros-on-multiple-machines">5. Running ROS on multiple machines</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/6-slam-navigation">6. SLAM navigation</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/7-path-planning">7. Path planning</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/8-unknown-environment-exploration">8. Unknown environment exploration</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/9-object-search">9. Object search</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Mbed tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/mbed-tutorials/using-core2-with-mbed-os">1. Using CORE2 with Mbed OS</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Other tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/hframework-library-development">1. hFramework library development</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/offline-development-tools">2. Offline development tools</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/how-to-use-core2-ros-local-serial-offline">3. How to use CORE2-ROS local serial offline</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/run-ros-tutorials-using-aws-robomaker">4. Run ROS tutorials using AWS RoboMaker</a></li></ul></div></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Creating nodes</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="workspace-setup"></a><a href="#workspace-setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Workspace setup</h2>
<p>To begin developing your own nodes, you need to do some workspace
configuration first. Workspace is the place where all your source files,
libraries and compiled nodes will be stored.</p>
<p>First you need to create a folder, where your workspace will be located.
You can do this by typing in:</p>
<pre><code class="hljs"> $ mkdir -p ~/ros_workspace/src
</code></pre>
<p>This will create folder named <code>ros_workspace</code> and folder <code>src</code> inside it.
All of the source files for your nodes will be stored in folder <code>src</code>.</p>
<p>Then you can initialize your workspace with command
<code>catkin_init_workspace</code> executed in <code>src</code> folder:</p>
<pre><code class="hljs">$ cd ~/ros_workspace/src
$ catkin_init_workspace
</code></pre>
<p>Now you can move to your workspace main directory:</p>
<pre><code class="hljs">$ cd ~/ros_workspace
</code></pre>
<p>and compile it:</p>
<pre><code class="hljs">$ catkin_make
</code></pre>
<p>After this command you should get output like this:</p>
<p><img src="../../assets/img/ros/man_2_1.png" alt="image"></p>
<p>And it should end with:</p>
<pre><code class="hljs">####
#### Running command: &quot;make -j4 -l4&quot; in &quot;/home/pi/ros_workspace/build&quot;
####
</code></pre>
<p>After this operation you should have two new folders in your workspace:
<code>build</code> for storing files that are used during compilation and <code>devel</code>
for storing output files.</p>
<p>Now your workspace is set up and ready for creating new nodes.</p>
<h2><a class="anchor" aria-hidden="true" id="creating-new-package"></a><a href="#creating-new-package" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating new package</h2>
<p>As you should already know, in ROS, nodes are distributed in packages, so
in order to create a node you need to create a package. Packages are
created with command <code>catkin_create_pkg</code> and it must be executed in
<code>src</code> folder in your workspace.</p>
<p>Syntax of <code>catkin_create_pkg</code> is:</p>
<pre><code class="hljs">catkin_create_pkg package_name [required packages]
</code></pre>
<p>where <code>package_name</code> is desired package name and argument
<code>required packages</code> is optional and contain names of packages that are used
by newly created packages.</p>
<p>For our tutorial we will create package named <code>tutorial_pkg</code> which
depends on package <code>roscpp</code>. Package <code>roscpp</code> is a basic ROS library for
C++.</p>
<pre><code class="hljs">$ cd ~/ros_workspace/src 
$ catkin_create_pkg tutorial_pkg roscpp
</code></pre>
<p>After typing in this command you should get output like this:</p>
<p><img src="../../assets/img/ros/man_2_2.png" alt="image"></p>
<p>This will create folder named <code>tutorial_pkg</code> and some files in it. Your
workspace file structure should now look like like below:</p>
<p><img src="../../assets/img/ros/man_2_1a.png" alt="image"></p>
<p>Created files are:</p>
<ul>
<li><p><code>CMakeLists.txt</code> - these are build instructions for your nodes, you
need to edit this file if you want to compile any node, we will do
it later.</p></li>
<li><p><code>package.xml</code> - this file contains package metadata like author,
description, version or required packages. Package can be built
without changing it, but you should adjust this file if you want to
publish your package to others.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="write-code-for-your-first-node"></a><a href="#write-code-for-your-first-node" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write code for your first node</h3>
<p>Let’s create C++ file for your node, name it <code>tutorial_pkg_node.cpp</code> and
place it in <code>src</code> folder under <code>tutorial_pkg</code>:</p>
<pre><code class="hljs">$ touch ~/ros_workspace/src/tutorial_pkg/src/tutorial_pkg_node.cpp
</code></pre>
<p>Open file in your favourite text editor and paste:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     
     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           loop_rate.sleep();
        }
     }
</code></pre>
<p>Code explanation line by line:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
</code></pre>
<p>Add header files for basic ROS libraries.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
</code></pre>
<p>Beginning of node main function.</p>
<pre><code class="hljs css language-cpp">    ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
</code></pre>
<p>Initialization of ROS node, this function contacts with ROS master and
registers node in the system.</p>
<pre><code class="hljs css language-cpp">    ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
</code></pre>
<p>Get the handle for node, this handle is required for interactions with
system e.g. subscribing to topic.</p>
<pre><code class="hljs css language-cpp">    ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
</code></pre>
<p>Define rate for repeatable operations.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">while</span> (ros::ok()) {
</code></pre>
<p>Check if ROS is working. E.g. if ROS master is stopped or there was sent
signal to stop the system, <code>ros::ok()</code> will return false.</p>
<pre><code class="hljs css language-cpp">    ros::spinOnce();
</code></pre>
<p>Process all incoming messages.</p>
<pre><code class="hljs css language-cpp">    loop_rate.sleep();
</code></pre>
<p>Wait until defined time passes.</p>
<p>You can save the C++ file.</p>
<h3><a class="anchor" aria-hidden="true" id="building-your-node"></a><a href="#building-your-node" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building your node</h3>
<p>Before you build the node, you need to edit <code>CMakeLists.txt</code> from
<code>tutorial_pkg</code> directory. Open it in your favourite text editor.</p>
<p>Find line:</p>
<pre><code class="hljs"># add_compile_options(-std=c++11)
</code></pre>
<p>and uncomment it (remove <code>#</code> sign). This will allow to use C++11 standard of C++.</p>
<p>You should also find and uncomment line:</p>
<pre><code class="hljs"># add_executable(${PROJECT_NAME}_node src/tutorial_pkg_node.cpp)
</code></pre>
<p>This will let the compiler know that it should create executable
file from defined source. Created executable
will be your node. Variable <code>PROJECT_NAME</code> is defined by line <code>project(tutorial_pkg)</code>.
This results in <code>tutorial_pkg_node</code> as the name of the executable. You can adjust it to your needs.</p>
<p>After that find and uncomment lines:</p>
<pre><code class="hljs"># target_link_libraries(${PROJECT_NAME}_node
#   ${catkin_LIBRARIES}
# )
</code></pre>
<p>This will cause compiler to link libraries required by your node. Save
the changes and close editor.</p>
<p>Open terminal, move to workspace main directory and build your project
with command <code>catkin_make</code>:</p>
<pre><code class="hljs">$ cd ~/ros_workspace 
$ catkin_make
</code></pre>
<p>You should get output like this:</p>
<p><img src="../../assets/img/ros/man_2_3.png" alt="image"></p>
<h3><a class="anchor" aria-hidden="true" id="running-your-node"></a><a href="#running-your-node" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Running your node</h3>
<p>Your node is built and ready for running, but before you run it, you
need to load some environment variables:</p>
<pre><code class="hljs">$ source ~/ros_workspace/devel/setup.sh
</code></pre>
<p>These environment variables allow you to run node regardless of
directory you are working in. You have to load it every time you open
new terminal or you can add line:</p>
<pre><code class="hljs">. ~/ros_workspace/devel/setup<span class="hljs-selector-class">.sh</span>
</code></pre>
<p>to your <code>.bashrc</code> file.</p>
<p>To run your node you can use command line or <code>.launch</code> file as with any
other node. Remember that package is <code>tutorial_pkg</code> and node is
<code>tutorial_pkg_node</code>.</p>
<p><strong>Task 1</strong> Run your node with command line or <code>.launch</code> file. Then use
<code>rosnode</code> and <code>rqt_graph</code> tools to examine system and check if your node
is visible in the system.</p>
<p>To remind, you can start ROS by typing in the name of the node, you can do this
with the following command:</p>
<pre><code class="hljs">$ rosrun package_name node_type [options]
</code></pre>
<p>If you want to use <code>.launch</code> files associated with your custom package you will have to create <code>launch</code> directory:</p>
<pre><code class="hljs">$ mkdir ~/ros_workspace/src/tutorial_pkg/launch
</code></pre>
<p>Place your <code>.launch</code> files there. This way you can start them by typing:</p>
<pre><code class="hljs">$ roslaunch tutorial_pkg your_launch_file.launch
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="subscribing-to-topic"></a><a href="#subscribing-to-topic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Subscribing to topic</h3>
<p>You will modify your node to subscribe to topic
<code>/camera/rgb/image_raw</code> and calculate average brightness of image.</p>
<p>To process message received from the camera you need a header file with
message type definition. You can include it with:</p>
<pre><code class="hljs">#include &lt;sensor_msgs/Image.h&gt;
</code></pre>
<p>Image message is an object consisting of following fields:</p>
<ul>
<li><p><code>std_msgs/Header header</code> - header with message metedata</p></li>
<li><p><code>uint32 height</code> - image height in pixels</p></li>
<li><p><code>uint32 width</code> - image width in pixels</p></li>
<li><p><code>string encoding</code> - pixel encoding definition</p></li>
<li><p><code>uint8 is_bigendian</code> - is data expressed in bigendian manner</p></li>
<li><p><code>uint32 step</code> - length of data for one row</p></li>
<li><p><code>std::vector&lt;uint8_t&gt; data</code> - actual image data</p></li>
</ul>
<p>Then you need a function for processing received message:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
       <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> value : image-&gt;data )
       {
          sum+=value;
       }
       <span class="hljs-keyword">int</span> avg = sum/image-&gt;data.size();
       <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
</code></pre>
<p>Code explanation line by line:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span>
</span></code></pre>
<p>Function definition, argument is pointer to incoming message.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
</code></pre>
<p>Variable for storing sum of all pixel values.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> value : image-&gt;data )
</code></pre>
<p>Iteration through every pixel and colour.</p>
<pre><code class="hljs css language-cpp">    sum+=value;
</code></pre>
<p>Add current pixel value to sum.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">int</span> avg = sum/image-&gt;data.size();
</code></pre>
<p>Calculate average value.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre>
<p>Print brightness value to screen.</p>
<p>Last thing to do is defining topic to subscribe:</p>
<pre><code class="hljs css language-cpp">    ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
</code></pre>
<p>Here we use method <code>subscribe</code> of <code>NodeHandle</code> object. Arguments of
method are:</p>
<ul>
<li><p><code>/camera/rgb/image_raw</code> - name of topic to subscribe.</p></li>
<li><p><code>10</code> - message queue size. Messages are processed in order they come
in. In the case that node receives, in short time, more messages
than this value, excessive messages will be dropped.</p></li>
<li><p><code>imageCallback</code> - function to process incoming messages.</p></li>
</ul>
<p>Your final code should look like this:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Image.h&gt;</span></span>

     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : image-&gt;data) {
           sum += value;
        }
        <span class="hljs-keyword">int</span> avg = sum / image-&gt;data.size();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
     }

     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           loop_rate.sleep();
        }
     }
</code></pre>
<p><strong>Task 2</strong> Build your node and run it along with camera driver. Use
<code>rosnode</code>, <code>rostopic</code> and <code>rqt_graph</code> tools to examine system and check
how data is passed between nodes.</p>
<p>You can use below <code>.launch</code> file:</p>
<pre><code class="hljs css language-launch">&lt;launch&gt;

    &lt;arg <span class="hljs-type">name</span>="use_rosbot" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="use_gazebo" default="false"/&gt;

    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_rosbot)" file="$(find astra_launch)/launch/astra.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot_world.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot.launch"/&gt;
    
    &lt;node pkg="tutorial_pkg" <span class="hljs-keyword">type</span>="tutorial_pkg_node" <span class="hljs-type">name</span>="tutorial_pkg_node" output="screen"&gt;
    &lt;/node&gt;

&lt;/launch&gt;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="receiving-parameters"></a><a href="#receiving-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Receiving parameters</h3>
<p>Your node can receive parameters, they are used to customize behaviour
of node e.g. subscribed topic name, device name or transmission speed
for serial port.</p>
<p>You will modify a node to receive boolean parameter which defines if node
should print image brightness to screen.</p>
<p>To receive the parameter you need a variable to store its value, in this
example variable should have a global scope:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">bool</span> print_b;
</code></pre>
<p>Then receive parameter value:</p>
<pre><code class="hljs css language-cpp">    n.param&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-string">"print_brightness"</span>, print_b, <span class="hljs-literal">false</span>);
</code></pre>
<p>Here we use method <code>param</code> of <code>NodeHandle</code> object. Arguments of method
are:</p>
<ul>
<li><p><code>print_brightness</code> - name of parameter to receive.</p></li>
<li><p><code>print_b</code> - variable to store parameter value.</p></li>
<li><p><code>false</code> - parameter default value.</p></li>
</ul>
<p>Last thing is to print brightness dependant on parameter value:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">if</span>(print_b){
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
</code></pre>
<p>Your final code should look like this:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Image.h&gt;</span></span>
     
     <span class="hljs-keyword">bool</span> print_b;

     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : image-&gt;data) {
           sum += value;
        }
        <span class="hljs-keyword">int</span> avg = sum / image-&gt;data.size();
        <span class="hljs-keyword">if</span>(print_b){
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
     }

     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
        n.param&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-string">"print_brightness"</span>, print_b, <span class="hljs-literal">false</span>);
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           loop_rate.sleep();
        }
     }
</code></pre>
<p><strong>Task 3</strong> Run your node with parameter <code>print_brightness</code> set to <code>true</code>
and again set to <code>false</code>. Observe how behaviour of node changes.</p>
<h3><a class="anchor" aria-hidden="true" id="publishing-to-topic"></a><a href="#publishing-to-topic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publishing to topic</h3>
<p>You will modify node to publish brightness value to a new topic with
message of type <code>std_msgs/UInt8</code>. Message <code>std_msgs/UInt8</code> is object
with only one field <code>data</code>, which contain actual integer data.</p>
<p>Begin with including message header file:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/UInt8.h&gt;</span></span>
</code></pre>
<p>Next define publisher object with global scope:</p>
<pre><code class="hljs css language-cpp">    ros::Publisher brightness_pub;
</code></pre>
<p>Then register in the system to publish to a specific topic:</p>
<pre><code class="hljs css language-cpp">    brightness_pub = n.advertise&lt;std_msgs::UInt8&gt;(<span class="hljs-string">"brightness"</span> , <span class="hljs-number">1</span>);
</code></pre>
<p>Here we use method <code>advertise</code> of <code>NodeHandle</code> object. Arguments of
method are:</p>
<ul>
<li><p><code>brightness</code> - topic name.</p></li>
<li><p><code>1</code> - message queue size.</p></li>
</ul>
<p>You also need to declare type of message which will be published, in this
case it is <code>std_msgs::UInt8</code>.</p>
<p>Last thing is to put some data into message and send it to topic with
some frequency:</p>
<pre><code class="hljs css language-cpp">    std_msgs::UInt8 brightness_value;
    brightness_value.data=avg;
    brightness_pub.publish(brightness_value);
</code></pre>
<p>In our example it can be done while processing each message incoming
from camera topic.</p>
<p>Your final code should look like this:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Image.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/UInt8.h&gt;</span></span>
     
     <span class="hljs-keyword">bool</span> print_b;
     ros::Publisher brightness_pub;

     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : image-&gt;data) {
           sum += value;
        }
        <span class="hljs-keyword">int</span> avg = sum / image-&gt;data.size();
        <span class="hljs-keyword">if</span>(print_b){
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
        std_msgs::UInt8 brightness_value;
        brightness_value.data=avg;
        brightness_pub.publish(brightness_value);
     }

     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
        n.param&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-string">"print_brightness"</span>, print_b, <span class="hljs-literal">false</span>);
        brightness_pub = n.advertise&lt;std_msgs::UInt8&gt;(<span class="hljs-string">"brightness"</span> , <span class="hljs-number">1</span>);
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           loop_rate.sleep();
        }
     }
</code></pre>
<p><strong>Task 4</strong> Compile your node and run it with <code>astra.launch</code>. Use <code>rosnode</code>,
<code>rostopic</code> and <code>rqt_graph</code> tools to examine the system, then use
<code>rostopic echo</code> tool to read brightness of the image from the camera.</p>
<h3><a class="anchor" aria-hidden="true" id="calling-the-service"></a><a href="#calling-the-service" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Calling the service</h3>
<p>You will modify node to call to a service with message type
<code>std_srvs/Empty</code>, this type has no field and can not carry any data, it
can be used only for invoking action in another node and getting reply
when its done.</p>
<p>As a service provider we will use <code>image_saver</code> node from <code>image_view</code>
package. <code>Image_saver</code> have one service named <code>save</code>. every time it is
called, one frame from subscribed image topic is saved to hard drive.</p>
<p>Desired node behaviour is to count incoming frames and call service once
per given number of frames.</p>
<p>Begin with importing required header files:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_srvs/Empty.h&gt;</span></span>
</code></pre>
<p>We need one variable for counting passed frames:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">int</span> frames_passed = <span class="hljs-number">0</span>;
</code></pre>
<p>In <code>imageCallback</code> function increment counter with every incoming
message:</p>
<pre><code class="hljs css language-cpp">    frames_passed++;
</code></pre>
<p>Create a client which will be caling to service:</p>
<pre><code class="hljs css language-cpp">    ros::ServiceClient client = n.serviceClient&lt;std_srvs::Empty&gt;(<span class="hljs-string">"/image_saver/save"</span>);
</code></pre>
<p>Here we use method <code>serviceClient</code> of <code>NodeHandle</code> object. Method has
only one argument, it is the name of service. You also need to determine
message type for service: <code>std_srvs::Empty</code>.</p>
<p>Instantiate message object:</p>
<pre><code class="hljs css language-cpp">    std_srvs::Empty srv;
</code></pre>
<p>Check if required number of frames passed and reset counter:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">if</span> (frames_passed&gt;<span class="hljs-number">100</span>){
             frames_passed=<span class="hljs-number">0</span>;
</code></pre>
<p>Call the service:</p>
<pre><code class="hljs css language-cpp">    client.call(srv);
</code></pre>
<p>Your final code should look like this:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Image.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/UInt8.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_srvs/Empty.h&gt;</span></span>
     
     <span class="hljs-keyword">bool</span> print_b;
     ros::Publisher brightness_pub;
     <span class="hljs-keyword">int</span> frames_passed = <span class="hljs-number">0</span>;

     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : image-&gt;data) {
           sum += value;
        }
        <span class="hljs-keyword">int</span> avg = sum / image-&gt;data.size();
        <span class="hljs-keyword">if</span>(print_b){
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
        std_msgs::UInt8 brightness_value;
        brightness_value.data=avg;
        brightness_pub.publish(brightness_value);
        frames_passed++;
     }

     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
        n.param&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-string">"print_brightness"</span>, print_b, <span class="hljs-literal">false</span>);
        brightness_pub = n.advertise&lt;std_msgs::UInt8&gt;(<span class="hljs-string">"brightness"</span> , <span class="hljs-number">1</span>);
        ros::ServiceClient client = n.serviceClient&lt;std_srvs::Empty&gt;(<span class="hljs-string">"/image_saver/save"</span>);
        std_srvs::Empty srv;
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           <span class="hljs-keyword">if</span> (frames_passed&gt;<span class="hljs-number">100</span>){
              frames_passed=<span class="hljs-number">0</span>;
              client.call(srv);
           }
           loop_rate.sleep();
        }
     }
</code></pre>
<p><strong>Task 5</strong> Build your node and run it with <code>astra.launch</code> and <code>image_saver</code>.
Use <code>rosnode</code>, <code>rostopic</code> and <code>rqt_graph</code> tools to examine the system
and check how data is passed between nodes. Let the nodes work for a
certain time. Observe as new frames are being saved to your workspace
directory.</p>
<p>You can use below <code>.launch</code> file:</p>
<pre><code class="hljs css language-launch">&lt;launch&gt;

    &lt;arg <span class="hljs-type">name</span>="use_rosbot" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="use_gazebo" default="false"/&gt;

    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_rosbot)" file="$(find astra_launch)/launch/astra.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot_world.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot.launch"/&gt;

    &lt;node pkg="image_view" <span class="hljs-keyword">type</span>="image_saver" <span class="hljs-type">name</span>="image_saver"&gt;
        &lt;param <span class="hljs-type">name</span>="save_all_image" <span class="hljs-keyword">value</span>="false" /&gt;
        &lt;param <span class="hljs-type">name</span>="filename_format" <span class="hljs-keyword">value</span>="$(env HOME)/ros_workspace/image%04d.%s"/&gt;
        &lt;remap <span class="hljs-keyword">from</span>="/image" <span class="hljs-keyword">to</span>="/camera/rgb/image_raw"/&gt;
    &lt;/node&gt;

    &lt;node pkg="tutorial_pkg" <span class="hljs-keyword">type</span>="tutorial_pkg_node" <span class="hljs-type">name</span>="tutorial_pkg_node" output="screen"&gt;
        &lt;param <span class="hljs-type">name</span>="print_brightness" <span class="hljs-keyword">value</span>="false"/&gt;
    &lt;/node&gt;

&lt;/launch&gt;
</code></pre>
<p>To delete image files created by this example run following command in your <code>ros_workspace</code> directory:</p>
<pre><code class="hljs">$ rm $(find image*)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="providing-a-service"></a><a href="#providing-a-service" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing a service</h3>
<p>You will modify node to provide a service, which returns information
regarding how many images were saved. This service will have a message
type <code>std_srvs/Trigger</code>, it has no field for request and two fields for
response: integer to indicate if service was triggered successfully or
not and string for short summary of executed action.</p>
<p>Start with including required header files:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_srvs/Trigger.h&gt;</span></span>
</code></pre>
<p>Add variable for storing number of saved images:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">int</span> saved_imgs = <span class="hljs-number">0</span>;
</code></pre>
<p>Next, you need a function to execute when service is called:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">saved_img</span><span class="hljs-params">(std_srvs::Trigger::Request  &amp;req, std_srvs::Trigger::Response &amp;res)</span>
    </span>{
       res.success=<span class="hljs-number">1</span>;
       <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"Saved images: "</span>)</span></span>;
       <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> num = <span class="hljs-built_in">std</span>::to_string(saved_imgs);
       str.append(num);
       res.message= str;
       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
</code></pre>
<p>Arguments for this function are pointers to request and response data.
All services are called the same way, even if it does not carry any
data, in that case these are pointer of void type.</p>
<p>Prepare string with response description:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"Saved images: "</span>)</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> num = <span class="hljs-built_in">std</span>::to_string(saved_imgs);
    str.append(num);
</code></pre>
<p>Fill string field with data:</p>
<pre><code class="hljs css language-cpp">    res.message= str;
</code></pre>
<p>Fill integer field with data, this mean service was executed properly:</p>
<pre><code class="hljs css language-cpp">    res.success=<span class="hljs-number">1</span>;
</code></pre>
<p>Finish function, response will be sent to requesting node:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</code></pre>
<p>next thing to do is to increment image counter after saving frame:</p>
<pre><code class="hljs css language-cpp">    saved_imgs++;
</code></pre>
<p>Last thing to do is to register provided service in the system:</p>
<pre><code class="hljs css language-cpp">    ros::ServiceServer service = n.advertiseService(<span class="hljs-string">"saved_images"</span>, saved_img);
</code></pre>
<p>Here we use method <code>advertiseService</code> of <code>NodeHandle</code> object. Arguments
of method are:</p>
<ul>
<li><p><code>saved_images</code> - service name.</p></li>
<li><p><code>saved_img</code> - method to execute.</p></li>
</ul>
<p>Your final code should look like this:</p>
<pre><code class="hljs css language-cpp">     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Image.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/UInt8.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_srvs/Empty.h&gt;</span></span>
     <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_srvs/Trigger.h&gt;</span></span>

     <span class="hljs-keyword">bool</span> print_b;
     ros::Publisher brightness_pub;
     <span class="hljs-keyword">int</span> frames_passed = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">int</span> saved_imgs = <span class="hljs-number">0</span>;

     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::ImageConstPtr &amp;image)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : image-&gt;data) {
           sum += value;
        }
        <span class="hljs-keyword">int</span> avg = sum / image-&gt;data.size();
        <span class="hljs-keyword">if</span> (print_b) {
           <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Brightness: "</span> &lt;&lt; avg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
        std_msgs::UInt8 brightness_value;
        brightness_value.data = avg;
        brightness_pub.publish(brightness_value);
        frames_passed++;
     }

     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">saved_img</span><span class="hljs-params">(std_srvs::Trigger::Request &amp;req, std_srvs::Trigger::Response &amp;res)</span> </span>{
        res.success = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"Saved images: "</span>)</span></span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> num = <span class="hljs-built_in">std</span>::to_string(saved_imgs);
        str.append(num);
        res.message = str;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
     }

     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        ros::init(argc, argv, <span class="hljs-string">"example_node"</span>);
        ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
        ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/camera/rgb/image_raw"</span>, <span class="hljs-number">10</span>, imageCallback);
        n.param&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-string">"print_brightness"</span>, print_b, <span class="hljs-literal">false</span>);
        brightness_pub = n.advertise&lt;std_msgs::UInt8&gt;(<span class="hljs-string">"brightness"</span>, <span class="hljs-number">1</span>);
        ros::ServiceClient client = n.serviceClient&lt;std_srvs::Empty&gt;(<span class="hljs-string">"/image_saver/save"</span>);
        std_srvs::Empty srv;
        ros::ServiceServer service = n.advertiseService(<span class="hljs-string">"saved_images"</span>, saved_img);
        ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
        <span class="hljs-keyword">while</span> (ros::ok()) {
           ros::spinOnce();
           <span class="hljs-keyword">if</span> (frames_passed &gt; <span class="hljs-number">100</span>) {
              frames_passed = <span class="hljs-number">0</span>;
              client.call(srv);
              saved_imgs++;
           }
           loop_rate.sleep();
        }
     }
</code></pre>
<p><strong>Task 6</strong> Build your node and run it as in previous task. Use
<code>rosnode</code>, <code>rostopic</code> and <code>rqt_graph</code> tools to examine the system.</p>
<p>Use <code>rosservice call</code> tool to call service provided by your node. Usage
of <code>rosservice</code> is analogical to <code>rostopic</code>. To call service type:</p>
<pre><code class="hljs">$ rosservice call /tutorial_pkg_node/saved_images
</code></pre>
<p>As a response you should get something like this:</p>
<p><img src="../../assets/img/ros/man_2_7.png" alt="image"></p>
<h2><a class="anchor" aria-hidden="true" id="message-types"></a><a href="#message-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Message types</h2>
<p>In ROS there are many message types defined, they are grouped in
packages accordingly to their application:</p>
<ul>
<li><p><a href="http://docs.ros.org/kinetic/api/std_msgs/html/index-msg.html"><code>std_msgs</code></a></p>
<ul>
<li>messages with basic data types like integer or float</li>
</ul></li>
<li><p><a href="http://docs.ros.org/jade/api/sensor_msgs/html/index-msg.html"><code>sensor_msgs</code></a></p>
<ul>
<li>for handling data from sensors</li>
</ul></li>
<li><p><a href="http://docs.ros.org/jade/api/nav_msgs/html/index-msg.html"><code>nav_msgs</code></a></p>
<ul>
<li>for handling maps or robot localization data</li>
</ul></li>
<li><p><a href="http://docs.ros.org/jade/api/geometry_msgs/html/index-msg.html"><code>geometry_msgs</code></a></p>
<ul>
<li>for handling information regarding object position, orientation,
velocity or acceleration, also for defining points or polygons</li>
</ul></li>
</ul>
<p>While developing nodes for mobile robots you will probably want to use
some of this messages:</p>
<ul>
<li><p><a href="http://docs.ros.org/jade/api/sensor_msgs/html/msg/JointState.html"><code>sensor_msgs/JointState</code></a></p>
<ul>
<li>it has fields for determining position , velocity and effort for a
set of joints.</li>
</ul></li>
<li><p><a href="http://docs.ros.org/jade/api/sensor_msgs/html/msg/LaserScan.html"><code>sensor_msgs/LaserScan</code></a></p>
<ul>
<li>message for handling scans of planar laser scanners like RpLidar
or Hokuyo.</li>
</ul></li>
<li><p><a href="http://docs.ros.org/jade/api/sensor_msgs/html/msg/Range.html"><code>sensor_msgs/Range</code></a></p>
<ul>
<li>message for one dimensional distance measurement</li>
</ul></li>
<li><p><a href="http://docs.ros.org/api/nav_msgs/html/msg/OccupancyGrid.html"><code>nav_msgs/OccupancyGrid</code></a></p>
<ul>
<li>message for handling flat occupancy grid based maps.</li>
</ul></li>
<li><p><a href="http://docs.ros.org/api/nav_msgs/html/msg/Odometry.html"><code>nav_msgs/Odometry</code></a></p>
<ul>
<li>message for defining robot position and orientation based on
odometry measurements.</li>
</ul></li>
<li><p><a href="http://docs.ros.org/api/nav_msgs/html/msg/Path.html"><code>nav_msgs/Path</code></a></p>
<ul>
<li>message for defining robot path as a set of positions</li>
</ul></li>
<li><p><a href="http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html"><code>geometry_msgs/Twist</code></a></p>
<ul>
<li>message for defining linear and angular object velocity. Could be
also used for setting desired velocities.</li>
</ul></li>
</ul>
<p>It is also possible to implement user defined messages if existing ones
are not sufficient.</p>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p>After completing this tutorial you should be able to write code for your
own node, build and run it in the same way as it can be done with nodes
provided with ROS.</p>
<p>Your node may be configured with parameters and it can:</p>
<ul>
<li><p>subscribe topics published by other nodes</p></li>
<li><p>publish new topic</p></li>
<li><p>provide service</p></li>
<li><p>call service provided by other nodes</p></li>
</ul>
<hr>
<p><em>by Łukasz Mitka, Husarion</em></p>
<p><em>Do you need any support with completing this tutorial or have any difficulties with software or hardware? Feel free to describe your thoughts on our community forum: <a href="https://community.husarion.com/">https://community.husarion.com/</a> or to contact with our support: <a href="mailto:support@husarion.com">support@husarion.com</a></em></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/1-ros-introduction"><span class="arrow-prev">← </span><span>1. ROS introduction</span></a><a class="docs-next button" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/3-simple-kinematics-for-mobile-robot"><span>3. Simple kinematics for mobile robot</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#workspace-setup">Workspace setup</a></li><li><a href="#creating-new-package">Creating new package</a><ul class="toc-headings"><li><a href="#write-code-for-your-first-node">Write code for your first node</a></li><li><a href="#building-your-node">Building your node</a></li><li><a href="#running-your-node">Running your node</a></li><li><a href="#subscribing-to-topic">Subscribing to topic</a></li><li><a href="#receiving-parameters">Receiving parameters</a></li><li><a href="#publishing-to-topic">Publishing to topic</a></li><li><a href="#calling-the-service">Calling the service</a></li><li><a href="#providing-a-service">Providing a service</a></li></ul></li><li><a href="#message-types">Message types</a></li><li><a href="#summary">Summary</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docusaurus-husarion-docs/" class="nav-home"></a><div><h5>Company</h5><a href="https://husarion.com/about.html" target="_blank" rel="noreferrer noopener">About Us</a><a href="https://husarion.com/contact.html" target="_blank" rel="noreferrer noopener">Contact</a><a href="https://medium.com/husarion-blog" target="_blank" rel="noreferrer noopener">Blog</a><a href="https://cloud.husarion.com/tos" target="_blank" rel="noreferrer noopener">Terms of service</a></div><div><h5>Developers</h5><a href="#" target="_blank" rel="noreferrer noopener">Documentation</a><a href="https://cloud.husarion.com/" target="_blank" rel="noreferrer noopener">Husarion Cloud</a><a href="https://community.husarion.com/" target="_blank" rel="noreferrer noopener">Community forum</a><a href="https://husarion.com/downloads/" target="_blank" rel="noreferrer noopener">Downloads</a><a href="https://husarion.com" target="_blank" rel="noreferrer noopener">Home Page</a></div><div><h5>Social</h5><a href="https://www.facebook.com/husarionTechnology/" target="_blank" rel="noreferrer noopener">Facebook</a><a href="https://twitter.com/husarion" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://github.com/husarion" target="_blank" rel="noreferrer noopener">GitHub</a></div></section><section class="copyright">Copyright © 2018 Husarion sp. z o.o.</section></footer></div></body></html>