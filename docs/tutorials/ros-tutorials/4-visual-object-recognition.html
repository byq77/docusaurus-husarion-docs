<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Visual object recognition · Husarion Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;introduction&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#introduction&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Visual object recognition · Husarion Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://byq77.github.io/docusaurus-husarion-docs/index.html"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;introduction&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#introduction&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
"/><meta property="og:image" content="https://byq77.github.io/docusaurus-husarion-docs/img/favicon.ico"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://byq77.github.io/docusaurus-husarion-docs/img/favicon.ico"/><link rel="shortcut icon" href="/docusaurus-husarion-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="https://byq77.github.io/docusaurus-husarion-docs/js/scrollspy.js"></script><script type="text/javascript" src="https://byq77.github.io/docusaurus-husarion-docs/js/sidebarScroll.js"></script><script type="text/javascript" src="https://byq77.github.io/docusaurus-husarion-docs/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"diameter":56,"cornerOffset":20,"backgroundColor":"#d0112b","textColor":"#fff"}
          )
        });
        </script><link rel="stylesheet" href="/docusaurus-husarion-docs/css/main.css"/><script src="/docusaurus-husarion-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docusaurus-husarion-docs/"><img class="logo" src="/docusaurus-husarion-docs/img/hus_docs_logo_2.png" alt="Husarion Docs"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docusaurus-husarion-docs/docs/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/docusaurus-husarion-docs/docs/manuals/" target="_self">Manuals</a></li><li class=""><a href="/docusaurus-husarion-docs/docs/software/hframework" target="_self">Software</a></li><li class=""><a href="https://husarion.com/downloads/" target="_blank">Downloads</a></li><li class=""><a href="https://community.husarion.com/" target="_blank">Community</a></li><li class=""><a href="https://cloud.husarion.com/" target="_blank">Log In</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Tutorials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Tutorials<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/">About tutorials</a></li><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">How to start</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/run-your-first-program">1. Run your first program</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/video-streaming-from-a-camera">2. Video streaming</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/getting-started-with-husarion--lego-mindstorms">3. Getting started with Husarion + LEGO Mindstorms</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/telepresence-robot-kit---quick-start">4. Telepresence robot kit - quick start</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/using-third-party-modules">5. Using third-party modules</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/howtostart/rosbot---quick-start">6. ROSbot - quick start</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ROS tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/1-ros-introduction">1. ROS introduction</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/2-creating-nodes">2. Creating nodes</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/3-simple-kinematics-for-mobile-robot">3. Simple kinematics for mobile robot</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/4-visual-object-recognition">4. Visual object recognition</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/5-running-ros-on-multiple-machines">5. Running ROS on multiple machines</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/6-slam-navigation">6. SLAM navigation</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/7-path-planning">7. Path planning</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/8-unknown-environment-exploration">8. Unknown environment exploration</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/9-object-search">9. Object search</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Mbed tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/mbed-tutorials/using-core2-with-mbed-os">1. Using CORE2 with Mbed OS</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Other tutorials</h4><ul><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/hframework-library-development">1. hFramework library development</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/offline-development-tools">2. Offline development tools</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/how-to-use-core2-ros-local-serial-offline">3. How to use CORE2-ROS local serial offline</a></li><li class="navListItem"><a class="navItem" href="/docusaurus-husarion-docs/docs/tutorials/other-tutorials/run-ros-tutorials-using-aws-robomaker">4. Run ROS tutorials using AWS RoboMaker</a></li></ul></div></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Visual object recognition</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p>Objects can be recognized by a robot with use of a vision system. It is
based on image characteristics like points, lines, edges colours and
their relative positions.</p>
<p>Processing of object recognition consists of two steps. First is
teaching and should be executed before main robot operation. During this
step object is presented to the vision system, image and extracted set of
features are saved as a pattern. Many objects can be presented to the
system.</p>
<p>Second step is actual recognition which is executed constantly during
robot operation. Every frame of camera is processed, image features are
extracted and compared to data set in the memory. If enough features matches
the pattern, then the object is recognized.</p>
<p>In this tutorial we will use <code>find_object_2d</code> node from <code>find_object_2d</code>
package for both teaching and recognition.</p>
<p>As an image source we will use nodes from <code>astra.launch</code> as in tutorial 1.</p>
<h2><a class="anchor" aria-hidden="true" id="teaching-objects"></a><a href="#teaching-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Teaching objects</h2>
<p>Anything could be an object to recognize, but remember, that the more edges
and contrast colours it has, the easier it will be recognized. A piece
of paper with something drawn on it would be enough for this tutorial.</p>
<p>First you should run <code>find_object_2d</code> and <code>astra.launch</code>. Node
<code>find_object_2d</code> by default subscribe to <code>image</code> topic, you should remap
it to topic <code>/camera/rgb/image_raw</code>. We will also decrease the
camera framerate, as it is not necessary to check for objects so often
and it will use less CPU making interface more responsive.</p>
<p>You can use below <code>launch</code> file:</p>
<pre><code class="hljs">&lt;launch&gt;

    &lt;arg <span class="hljs-type">name</span>="use_rosbot" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="use_gazebo" default="false"/&gt;

    &lt;arg <span class="hljs-type">name</span>="teach" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="recognize" default="false"/&gt;

    &lt;arg <span class="hljs-keyword">if</span>="$(arg teach)" <span class="hljs-type">name</span>="chosen_world" <span class="hljs-keyword">value</span>="rosbot_world_teaching"/&gt;
    &lt;arg <span class="hljs-keyword">if</span>="$(arg recognize)" <span class="hljs-type">name</span>="chosen_world" <span class="hljs-keyword">value</span>="rosbot_world_recognition"/&gt;

    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_rosbot)" file="$(find astra_launch)/launch/astra.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/$(arg chosen_world).launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot.launch"/&gt;

    &lt;node <span class="hljs-type">name</span>="teleop_twist_keyboard" pkg="teleop_twist_keyboard" <span class="hljs-keyword">type</span>="teleop_twist_keyboard.py" output="screen"/&gt;

    &lt;node pkg="find_object_2d" <span class="hljs-keyword">type</span>="find_object_2d" <span class="hljs-type">name</span>="find_object_2d"&gt;
        &lt;remap <span class="hljs-keyword">from</span>="image" <span class="hljs-keyword">to</span>="/camera/rgb/image_raw"/&gt;
        &lt;param <span class="hljs-type">name</span>="gui" <span class="hljs-keyword">value</span>="$(arg teach)"/&gt;
        &lt;param <span class="hljs-keyword">if</span>="$(arg recognize)" <span class="hljs-type">name</span>="objects_path" <span class="hljs-keyword">value</span>="$(find tutorial_pkg)/image_rec/"/&gt;
    &lt;/node&gt;

&lt;/launch&gt;
</code></pre>
<p>To start teaching objects on ROSbot:</p>
<pre><code class="hljs css language-bash">roslaunch tutorial_pkg tutorial_4.launch use_rosbot:=<span class="hljs-literal">true</span> use_gazebo:=<span class="hljs-literal">false</span> teach:=<span class="hljs-literal">true</span> recognize:=<span class="hljs-literal">false</span>
</code></pre>
<p>To start teaching objects in Gazebo:</p>
<pre><code class="hljs css language-bash">roslaunch tutorial_pkg tutorial_4.launch use_rosbot:=<span class="hljs-literal">false</span> use_gazebo:=<span class="hljs-literal">true</span> teach:=<span class="hljs-literal">true</span> recognize:=<span class="hljs-literal">false</span>
</code></pre>
<p>To place objects in front of camera using Gazebo, you can use buttons <strong>Translation mode</strong> and <strong>Rotation mode</strong> in top left corner and drag objects to desired position. Another option is to drive ROSbot to look at the selected object.</p>
<p>After launching the <code>find_object_2d</code> node with properly adjusted image
topic, new window should appear:</p>
<p><img src="../../assets/img/ros/man_4_1.jpg" alt="image"></p>
<p>On the left side of the window there are thumbnails of saved images
(should be empty at first run). Application main window contains camera
view. Yellow circles on the image are marking extracted image features.</p>
<p>To begin teaching process choose from the main toolbar <strong><code>Edit</code></strong>
→ <strong><code>Add object from scene...</code>.</strong> New window will appear:</p>
<p><img src="../../assets/img/ros/man_4_2.jpg" alt="image"></p>
<p>Now move the object and camera in order to cover as many features of
the object as possible. While doing that try not to catch object surroundings. When it’s
done, click <strong><code>Take picture</code></strong>.</p>
<p><img src="../../assets/img/ros/man_4_3.jpg" alt="image"></p>
<p>In next view click <strong><code>Select region</code></strong> and select only that part of
taken picture, that covers desired object and click <strong><code>Next</code></strong>.</p>
<p><img src="../../assets/img/ros/man_4_4.jpg" alt="image"></p>
<p>You will get confirmation of features extracted from selected image
area. If presented image is in accordance with what you selected,
click <strong><code>End</code></strong></p>
<p><img src="../../assets/img/ros/man_4_5.jpg" alt="image"></p>
<p>You should see new thumbnail in the left panel. Notice the number outside of
parentheses on the left of the image, this is the object ID.</p>
<p>Now you can add some more objects to be recognized. Remember their IDs, you
will need them later:</p>
<p><img src="../../assets/img/ros/man_4_6.jpg" alt="image"></p>
<p><img src="../../assets/img/ros/man_4_7.jpg" alt="image"></p>
<p>When you have enough objects in the database choose from the main toolbar
<strong><code>File</code></strong> → <strong><code>Save objects...</code></strong> and choose a folder to
store recognized objects. Close the window and stop all running nodes.</p>
<h2><a class="anchor" aria-hidden="true" id="recognizing-objects"></a><a href="#recognizing-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Recognizing objects</h2>
<p>Objects will be recognized by the same node which was used for teaching but
it works in slightly different configuration. We will set two new parameters
for the node. For parameter <code>gui</code> we will set value <code>false</code>, this will run
node without window for learning objects as we no longer need it.
Another parameter will be <code>objects_path</code>, this should be a path to a folder
that you have just chosen to store recognized objects.</p>
<p>You can use the same launch file as for teaching, but with different parameter values.</p>
<p>On ROSbot:</p>
<pre><code class="hljs css language-bash">roslaunch tutorial_pkg tutorial_4.launch use_rosbot:=<span class="hljs-literal">true</span> use_gazebo:=<span class="hljs-literal">false</span> teach:=<span class="hljs-literal">false</span> recognize:=<span class="hljs-literal">true</span>
</code></pre>
<p>In Gazebo:</p>
<pre><code class="hljs css language-bash">roslaunch tutorial_pkg tutorial_4.launch use_rosbot:=<span class="hljs-literal">false</span> use_gazebo:=<span class="hljs-literal">true</span> teach:=<span class="hljs-literal">false</span> recognize:=<span class="hljs-literal">true</span>
</code></pre>
<p>Node is publishing to <code>/objects</code> topic with message type
<code>std_msgs/Float32MultiArray</code>. Data in this message is covering: object
ID, size of recognized object and its orientation. The most interesting
for us is object ID, this is first element of array.</p>
<p>Whenever object is recognized, it will be published in that topic. Place
different objects in front of camera and observe as their data is
published in the topic.</p>
<p>To watch messages published in the topic, you can use <code>rostopic</code> tool:</p>
<pre><code class="hljs">$ rostopic echo /objects
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="making-decision-with-recognized-object"></a><a href="#making-decision-with-recognized-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making decision with recognized object</h2>
<p>To perform a robot action based on recognized object, we will make a new
node. It’s task will be to subscribe <code>/objects</code> topic and publish
message to <code>/cmd_vel</code> with speed and direction depending on the object.</p>
<p>Create a new file, name it <code>action_controller.cpp</code> and place it in <code>src</code>
folder under <code>tutorial_pkg</code>. Then open it in text editor and paste below code:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/Float32MultiArray.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMILE 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_LEFT 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_UP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_DOWN 6</span>

<span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
ros::Publisher action_pub;
geometry_msgs::Twist set_vel;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objectCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std_msgs::Float32MultiArrayPtr &amp;object)</span> </span>{
   <span class="hljs-keyword">if</span> (object-&gt;data.size() &gt; <span class="hljs-number">0</span>) {
      id = object-&gt;data[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">switch</span> (id) {
         <span class="hljs-keyword">case</span> ARROW_LEFT:
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_UP:
            set_vel.linear.x = <span class="hljs-number">1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_DOWN:
            set_vel.linear.x = <span class="hljs-number">-1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>: <span class="hljs-comment">// other object</span>
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
      }
      action_pub.publish(set_vel);
   } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// No object detected</span>
      set_vel.linear.x = <span class="hljs-number">0</span>;
      set_vel.angular.z = <span class="hljs-number">0</span>;
      action_pub.publish(set_vel);
   }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{

   ros::init(argc, argv, <span class="hljs-string">"action_controller"</span>);
   ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
   ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
   ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/objects"</span>, <span class="hljs-number">1</span>, objectCallback);
   action_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">"/cmd_vel"</span>, <span class="hljs-number">1</span>);
   set_vel.linear.x = <span class="hljs-number">0</span>;
   set_vel.linear.y = <span class="hljs-number">0</span>;
   set_vel.linear.z = <span class="hljs-number">0</span>;
   set_vel.angular.x = <span class="hljs-number">0</span>;
   set_vel.angular.y = <span class="hljs-number">0</span>;
   set_vel.angular.z = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (ros::ok()) {
      ros::spinOnce();
      loop_rate.sleep();
   }
}   
</code></pre>
<p>Below is an explanation of the code line by line.</p>
<p>Including required headers:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/Float32MultiArray.h&gt;</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span>
</code></pre>
<p>Defining constants for recognized objects, adjusting values to IDs of objects
recognized by your system:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMILE 8</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_LEFT 9</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_UP 10</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_DOWN 11</span>
</code></pre>
<p>Integer for storing object identifier:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
</code></pre>
<p>Publisher for velocity commands:</p>
<pre><code class="hljs css language-cpp">    ros::Publisher action_pub;
</code></pre>
<p>Velocity command message:</p>
<pre><code class="hljs css language-cpp">    geometry_msgs::Twist set_vel;
</code></pre>
<p>Callback function for handling incoming messages with recognized objects
data:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objectCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std_msgs::Float32MultiArrayPtr &amp;object)</span> </span>{
</code></pre>
<p>Checking if size of <code>data</code> field is non zero, if it is, then object is
recognized. When <code>data</code> field size is zero, then no object was
recognized.</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">if</span> (object-&gt;data.size() &gt; <span class="hljs-number">0</span>) {
</code></pre>
<p>Reading id of recognized object:</p>
<pre><code class="hljs css language-cpp">    id = object-&gt;data[<span class="hljs-number">0</span>];
</code></pre>
<p>Depending on recognized object, setting appropriate speed values:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">switch</span> (id) {
             <span class="hljs-keyword">case</span> ARROW_LEFT:
                set_vel.linear.x = <span class="hljs-number">0</span>;
                set_vel.angular.z = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
             <span class="hljs-keyword">case</span> ARROW_UP:
                set_vel.linear.x = <span class="hljs-number">1</span>;
                set_vel.angular.z = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">break</span>;
             <span class="hljs-keyword">case</span> ARROW_DOWN:
                set_vel.linear.x = <span class="hljs-number">-1</span>;
                set_vel.angular.z = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">break</span>;
             <span class="hljs-keyword">default</span>: <span class="hljs-comment">// other object</span>
                set_vel.linear.x = <span class="hljs-number">0</span>;
                set_vel.angular.z = <span class="hljs-number">0</span>;
          }
</code></pre>
<p>Publishing velocity command message:</p>
<pre><code class="hljs css language-cpp">    action_pub.publish(set_vel);
</code></pre>
<p>Stopping all motors when no object was detected:</p>
<pre><code class="hljs css language-cpp">    } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// No object detected</span>
          set_vel.linear.x = <span class="hljs-number">0</span>;
          set_vel.angular.z = <span class="hljs-number">0</span>;
          action_pub.publish(set_vel);
       }
</code></pre>
<p>Main function, node initialization and setting main loop interval:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
       ros::init(argc, argv, <span class="hljs-string">"action_controller"</span>);
       ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
       ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
</code></pre>
<p>Subscribing to <code>/objects</code> topic:</p>
<pre><code class="hljs css language-cpp">    ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/objects"</span>, <span class="hljs-number">1</span>, objectCallback);
</code></pre>
<p>Preparing publisher for velocity commands:</p>
<pre><code class="hljs css language-cpp">    action_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">"/cmd_vel"</span>, <span class="hljs-number">1</span>);
</code></pre>
<p>Setting zeros for initial speed values:</p>
<pre><code class="hljs css language-cpp">    set_vel.linear.x = <span class="hljs-number">0</span>;
       set_vel.linear.y = <span class="hljs-number">0</span>;
       set_vel.linear.z = <span class="hljs-number">0</span>;
       set_vel.angular.x = <span class="hljs-number">0</span>;
       set_vel.angular.y = <span class="hljs-number">0</span>;
       set_vel.angular.z = <span class="hljs-number">0</span>;
</code></pre>
<p>Main loop, waiting for trigger messages:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">while</span> (ros::ok()) {
          ros::spinOnce();
          loop_rate.sleep();
       }
</code></pre>
<p>Last thing to do is editting the <code>CMakeLists.txt</code> file. Find line:</p>
<pre><code class="hljs">add_executable(tutorial_pkg_node src/tutorial_pkg_node.cpp)
</code></pre>
<p>and add below code after it:</p>
<pre><code class="hljs">add_executable(action_controller_node src/action_controller.cpp)
</code></pre>
<p>Find also:</p>
<pre><code class="hljs">target_link_libraries(tutorial_pkg_node
  ${catkin_LIBRARIES}
)
</code></pre>
<p>and add below code after it:</p>
<pre><code class="hljs">target_link_libraries(action_controller_node
  ${catkin_LIBRARIES}
)
</code></pre>
<p>Now you can build your node and test it.</p>
<p><strong>Task 1</strong> Run your node along with <code>find_object_2d</code> and <code>astra.launch</code> or <strong>Gazebo</strong> simulator.
Then use <code>rosnode</code>, <code>rostopic</code> and <code>rqt_graph</code> tools to examine the
system. Place different objects in front of your robot one by one. Observe
how it drives and turns depending on differnt objects.</p>
<p>You can use below <code>launch</code> file:</p>
<pre><code class="hljs css language-launch">&lt;launch&gt;

    &lt;arg <span class="hljs-type">name</span>="use_rosbot" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="use_gazebo" default="false"/&gt;

    &lt;arg <span class="hljs-type">name</span>="teach" default="true"/&gt;
    &lt;arg <span class="hljs-type">name</span>="recognize" default="false"/&gt;

    &lt;arg <span class="hljs-keyword">if</span>="$(arg teach)" <span class="hljs-type">name</span>="chosen_world" <span class="hljs-keyword">value</span>="rosbot_world_teaching"/&gt;
    &lt;arg <span class="hljs-keyword">if</span>="$(arg recognize)" <span class="hljs-type">name</span>="chosen_world" <span class="hljs-keyword">value</span>="rosbot_world_recognition"/&gt;

    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_rosbot)" file="$(find astra_launch)/launch/astra.launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/$(arg chosen_world).launch"/&gt;
    &lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">if</span>="$(arg use_gazebo)" file="$(find rosbot_gazebo)/launch/rosbot.launch"/&gt;

    &lt;node <span class="hljs-type">name</span>="teleop_twist_keyboard" pkg="teleop_twist_keyboard" <span class="hljs-keyword">type</span>="teleop_twist_keyboard.py" output="screen"/&gt;

    &lt;node pkg="find_object_2d" <span class="hljs-keyword">type</span>="find_object_2d" <span class="hljs-type">name</span>="find_object_2d"&gt;
        &lt;remap <span class="hljs-keyword">from</span>="image" <span class="hljs-keyword">to</span>="/camera/rgb/image_raw"/&gt;
        &lt;param <span class="hljs-type">name</span>="gui" <span class="hljs-keyword">value</span>="$(arg teach)"/&gt;
        &lt;param <span class="hljs-keyword">if</span>="$(arg recognize)" <span class="hljs-type">name</span>="objects_path" <span class="hljs-keyword">value</span>="$(find tutorial_pkg)/image_rec/"/&gt;
    &lt;/node&gt;

    &lt;node pkg="tutorial_pkg" <span class="hljs-keyword">type</span>="action_controller_node" <span class="hljs-type">name</span>="action_controller" output="screen"/&gt;

&lt;/launch&gt;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="getting-position-of-recognized-object"></a><a href="#getting-position-of-recognized-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting position of recognized object</h2>
<p>Besides the ID of recognized object, <code>find_object_2d</code> node is also
publishing a homography matrix of recognized object. In computer vision
homography is used to define position of object relative to the camera. We
will use it to obtain horizontal position of the object. Homography matrix
is published in the same topic as the ID, but in the next cells of array,
they are formatted as</p>
<p><code>[objectId1, objectWidth, objectHeight, h11, h12, h13, h21, h22, h23, h31, h32, h33, object2]</code>.</p>
<p>We will modify node to rotate robot to the direction of recognized object.</p>
<p>Open <code>action_controller.cpp</code> file in text editor.</p>
<p>Begin with including of required header file:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span>
</code></pre>
<p>Variable for storing camera centre- this should be half of your camera
horizontal resolution:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">int</span> camera_center = <span class="hljs-number">320</span>; <span class="hljs-comment">// left 0, right 640</span>
</code></pre>
<p>Variables for defining rotation speed:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">float</span> max_ang_vel = <span class="hljs-number">0.6</span>;
    <span class="hljs-keyword">float</span> min_ang_vel = <span class="hljs-number">0.4</span>;
    <span class="hljs-keyword">float</span> ang_vel = <span class="hljs-number">0</span>;
</code></pre>
<p>Variable for object width and height:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">float</span> objectWidth = object-&gt;data[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">float</span> objectHeight = object-&gt;data[<span class="hljs-number">2</span>];
</code></pre>
<p>Variable for storing calculated object centre:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">float</span> x_pos;
</code></pre>
<p>Variable defining how much rotation speed should increase with every
pixel of object displacement:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">float</span> speed_coefficient = (<span class="hljs-keyword">float</span>) camera_center / max_ang_vel /<span class="hljs-number">4</span>;
</code></pre>
<p>Object for homography matrix:</p>
<pre><code class="hljs css language-cpp">    cv::<span class="hljs-function">Mat <span class="hljs-title">cvHomography</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32F)</span></span>;
</code></pre>
<p>Vectors for storing input and output planes:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;cv::Point2f&gt; inPts, outPts;
</code></pre>
<p>Adding new case in <code>switch</code> statement:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">case</span> SMILE:
</code></pre>
<p>Extracting coefficients homography matrix:</p>
<pre><code class="hljs css language-cpp">    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">3</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">4</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">5</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">6</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">7</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">8</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">9</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">10</span>];
    cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">11</span>];
</code></pre>
<p>Defining corners of input plane:</p>
<pre><code class="hljs css language-cpp">    inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
    inPts.push_back(cv::Point2f(objectWidth, <span class="hljs-number">0</span>));
    inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, objectHeight));
    inPts.push_back(cv::Point2f(objectWidth, objectHeight));
</code></pre>
<p>Calculating perspective transformation:</p>
<pre><code class="hljs css language-cpp">    cv::perspectiveTransform(inPts, outPts, cvHomography);
</code></pre>
<p>Calculating centre of object from its corners:</p>
<pre><code class="hljs css language-cpp">    x_pos = (<span class="hljs-keyword">int</span>) (outPts.at(<span class="hljs-number">0</span>).x + outPts.at(<span class="hljs-number">1</span>).x + outPts.at(<span class="hljs-number">2</span>).x + outPts.at(<span class="hljs-number">3</span>).x) / <span class="hljs-number">4</span>;
</code></pre>
<p>Calculating angular speed value proportional to position of object and putting
it into velocity message:</p>
<pre><code class="hljs css language-cpp">            ang_vel = -(x_pos - camera_center) / speed_coefficient;
            
            <span class="hljs-keyword">if</span> (ang_vel &gt;= -(min_ang_vel/<span class="hljs-number">2</span>) &amp;&amp; ang_vel &lt;= (min_ang_vel/<span class="hljs-number">2</span>)){
                set_vel.angular.z = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &gt;=max_ang_vel){
        set_vel.angular.z = max_ang_vel;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &lt;=-max_ang_vel){
        set_vel.angular.z = -max_ang_vel;
        }
        <span class="hljs-keyword">else</span> {
        set_vel.angular.z = ang_vel;
        }
</code></pre>
<p>Your final file should look like this:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/Float32MultiArray.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/String.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMILE 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_LEFT 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_UP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_DOWN 6</span>
<span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
ros::Publisher action_pub;
geometry_msgs::Twist set_vel;
<span class="hljs-keyword">int</span> camera_center = <span class="hljs-number">320</span>; <span class="hljs-comment">// left 0, right 640</span>
<span class="hljs-keyword">float</span> max_ang_vel = <span class="hljs-number">0.6</span>;
<span class="hljs-keyword">float</span> min_ang_vel = <span class="hljs-number">0.4</span>;
<span class="hljs-keyword">float</span> ang_vel = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objectCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std_msgs::Float32MultiArrayPtr &amp;object)</span> </span>{
   <span class="hljs-keyword">if</span> (object-&gt;data.size() &gt; <span class="hljs-number">0</span>) {
      id = object-&gt;data[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">float</span> objectWidth = object-&gt;data[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">float</span> objectHeight = object-&gt;data[<span class="hljs-number">2</span>];
      <span class="hljs-keyword">float</span> x_pos;
      <span class="hljs-keyword">float</span> speed_coefficient = (<span class="hljs-keyword">float</span>) camera_center / max_ang_vel /<span class="hljs-number">4</span>;

      <span class="hljs-comment">// Find corners OpenCV</span>
      cv::<span class="hljs-function">Mat <span class="hljs-title">cvHomography</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32F)</span></span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;cv::Point2f&gt; inPts, outPts;
      <span class="hljs-keyword">switch</span> (id) {
         <span class="hljs-keyword">case</span> ARROW_LEFT:
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">1.0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_UP:
            set_vel.linear.x = <span class="hljs-number">1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_DOWN:
            set_vel.linear.x = <span class="hljs-number">-1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> SMILE:
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">3</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">4</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">5</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">6</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">7</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">8</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">9</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">10</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">11</span>];

            inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
            inPts.push_back(cv::Point2f(objectWidth, <span class="hljs-number">0</span>));
            inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, objectHeight));
            inPts.push_back(cv::Point2f(objectWidth, objectHeight));
            cv::perspectiveTransform(inPts, outPts, cvHomography);

            x_pos = (<span class="hljs-keyword">int</span>) (outPts.at(<span class="hljs-number">0</span>).x + outPts.at(<span class="hljs-number">1</span>).x + outPts.at(<span class="hljs-number">2</span>).x + 
            outPts.at(<span class="hljs-number">3</span>).x) / <span class="hljs-number">4</span>;
            ang_vel = -(x_pos - camera_center) / speed_coefficient;
            
            <span class="hljs-keyword">if</span> (ang_vel &gt;= -(min_ang_vel/<span class="hljs-number">2</span>) &amp;&amp; ang_vel &lt;= (min_ang_vel/<span class="hljs-number">2</span>)){
                set_vel.angular.z = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &gt;=max_ang_vel){
        set_vel.angular.z = max_ang_vel;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &lt;=-max_ang_vel){
        set_vel.angular.z = -max_ang_vel;
        }
        <span class="hljs-keyword">else</span> {
        set_vel.angular.z = ang_vel;
        }
            
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>: <span class="hljs-comment">// other object</span>
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
      }
      action_pub.publish(set_vel);
   } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// No object detected</span>
      set_vel.linear.x = <span class="hljs-number">0</span>;
      set_vel.angular.z = <span class="hljs-number">0</span>;
      action_pub.publish(set_vel);
   }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
   std_msgs::String s;
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str;
   str.clear();
   str.append(<span class="hljs-string">""</span>);
   <span class="hljs-built_in">std</span>::to_string(<span class="hljs-number">3</span>);
   s.data = str;
   ros::init(argc, argv, <span class="hljs-string">"action_controller"</span>);
   ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
   ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/objects"</span>, <span class="hljs-number">1</span>, objectCallback);
   ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
   action_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">"/cmd_vel"</span>, <span class="hljs-number">1</span>);
   set_vel.linear.x = <span class="hljs-number">0</span>;
   set_vel.linear.y = <span class="hljs-number">0</span>;
   set_vel.linear.z = <span class="hljs-number">0</span>;
   set_vel.angular.x = <span class="hljs-number">0</span>;
   set_vel.angular.y = <span class="hljs-number">0</span>;
   set_vel.angular.z = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (ros::ok()) {
      ros::spinOnce();
      loop_rate.sleep();
   }
}
</code></pre>
<p>Last thing to do is to edit the <code>CMakeLists.txt</code> file. Find line:</p>
<pre><code class="hljs">find_package(catkin REQUIRED COMPONENTS roscpp )
</code></pre>
<p>and add below code after it:</p>
<pre><code class="hljs">find_package( OpenCV REQUIRED )
</code></pre>
<p>Find also:</p>
<pre><code class="hljs">include_directories(
        ${catkin_INCLUDE_DIRS}
)
</code></pre>
<p>and change it to:</p>
<pre><code class="hljs">include_directories(
        ${catkin_INCLUDE_DIRS}
        ${OpenCV_INCLUDE_DIRS}
)
</code></pre>
<p>Find:</p>
<pre><code class="hljs">target_link_libraries(action_controller_node
        ${catkin_LIBRARIES}
        )
</code></pre>
<p>and change it to:</p>
<pre><code class="hljs">target_link_libraries(action_controller_node
        ${catkin_LIBRARIES}
        ${OpenCV_LIBRARIES}
        )
</code></pre>
<p>Now you can build your node and test it.</p>
<p><strong>Task 2</strong> Run your node along with <code>find_object_2d</code> and <code>astra.launch</code> or <strong>Gazebo</strong> simulator.
Place the object with ID bonded to new case in switch statement in front of your robot. Observe how it turns towards the object.</p>
<h2><a class="anchor" aria-hidden="true" id="following-the-object"></a><a href="#following-the-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Following the object</h2>
<p>In this section you will modify your robot to turn and also drive
towards the object while keeping distance to it. For keeping the distance we
will use one of two different types of sensors.</p>
<p>Log in to Husarion Cloud and open project that you created in previous
manual. You will need to edit it a little.</p>
<p>Include required header files:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sensor_msgs/Range.h"</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"tf/tf.h"</span></span>
</code></pre>
<p>Message objects for all sensor measurement:</p>
<pre><code class="hljs css language-cpp">sensor_msgs::Range rangeFL;
sensor_msgs::Range rangeFR;
sensor_msgs::Range rangeRL;
sensor_msgs::Range rangeRR;
</code></pre>
<p>Publishers for measurement messages:</p>
<pre><code class="hljs css language-cpp">ros::Publisher *range_pub_fl;
ros::Publisher *range_pub_fr;
ros::Publisher *range_pub_rl;
ros::Publisher *range_pub_rr;
</code></pre>
<p>Function for initialization of publishers and messages with sensor parameters:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initDistanceSensorsPublisher</span><span class="hljs-params">()</span>
</span>{
    range_fl.header.frame_id = <span class="hljs-string">"range_fl"</span>;
    range_fr.header.frame_id = <span class="hljs-string">"range_fr"</span>;
    range_rl.header.frame_id = <span class="hljs-string">"range_rl"</span>;
    range_rr.header.frame_id = <span class="hljs-string">"range_rr"</span>;

    <span class="hljs-keyword">switch</span> (sensor_type)
    {
    <span class="hljs-keyword">case</span> SENSOR_LASER:
        range_fl.field_of_view = <span class="hljs-number">0.26</span>;
        range_fl.min_range = <span class="hljs-number">0.03</span>;
        range_fl.max_range = <span class="hljs-number">0.90</span>;

        range_fr.field_of_view = <span class="hljs-number">0.26</span>;
        range_fr.min_range = <span class="hljs-number">0.03</span>;
        range_fr.max_range = <span class="hljs-number">0.90</span>;

        range_rl.field_of_view = <span class="hljs-number">0.26</span>;
        range_rl.min_range = <span class="hljs-number">0.03</span>;
        range_rl.max_range = <span class="hljs-number">0.90</span>;

        range_rr.field_of_view = <span class="hljs-number">0.26</span>;
        range_rr.min_range = <span class="hljs-number">0.03</span>;
        range_rr.max_range = <span class="hljs-number">0.90</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> SENSOR_INFRARED:
        range_fl.radiation_type = sensor_msgs::Range::INFRARED;
        range_fl.field_of_view = <span class="hljs-number">0.26</span>;
        range_fl.min_range = <span class="hljs-number">0.05</span>;
        range_fl.max_range = <span class="hljs-number">0.299</span>;

        range_fr.radiation_type = sensor_msgs::Range::INFRARED;
        range_fr.field_of_view = <span class="hljs-number">0.26</span>;
        range_fr.min_range = <span class="hljs-number">0.05</span>;
        range_fr.max_range = <span class="hljs-number">0.299</span>;

        range_rl.radiation_type = sensor_msgs::Range::INFRARED;
        range_rl.field_of_view = <span class="hljs-number">0.26</span>;
        range_rl.min_range = <span class="hljs-number">0.05</span>;
        range_rl.max_range = <span class="hljs-number">0.299</span>;

        range_rr.radiation_type = sensor_msgs::Range::INFRARED;
        range_rr.field_of_view = <span class="hljs-number">0.26</span>;
        range_rr.min_range = <span class="hljs-number">0.05</span>;
        range_rr.max_range = <span class="hljs-number">0.299</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NO_DISTANCE_SENSOR:
        <span class="hljs-comment">// Do your own implementation</span>
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (sensor_type != SensorType::NO_DISTANCE_SENSOR)
    {
        range_pub_fl = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/fl"</span>, &amp;range_fl);
        range_pub_fr = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/fr"</span>, &amp;range_fr);
        range_pub_rl = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/rl"</span>, &amp;range_rl);
        range_pub_rr = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/rr"</span>, &amp;range_rr);
        nh.advertise(*range_pub_fl);
        nh.advertise(*range_pub_fr);
        nh.advertise(*range_pub_rl);
        nh.advertise(*range_pub_rr);
    }
}
</code></pre>
<p>Assign values to variables, put into messages and publish them:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">if</span> (sensor_type != SensorType::NO_DISTANCE_SENSOR)
{
    <span class="hljs-comment">// get ranges from distance sensors</span>
    ranges = rosbot.getRanges(sensor_type);
    range_fl.range = ranges[<span class="hljs-number">0</span>];
    range_fr.range = ranges[<span class="hljs-number">1</span>];
    range_rl.range = ranges[<span class="hljs-number">2</span>];
    range_rr.range = ranges[<span class="hljs-number">3</span>];
    Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Ranges %f %f %f %f\n"</span>, ranges[<span class="hljs-number">0</span>], ranges[<span class="hljs-number">1</span>], ranges[<span class="hljs-number">2</span>], ranges[<span class="hljs-number">3</span>]);
    <span class="hljs-comment">// publish ranges</span>
    range_pub_fl-&gt;publish(&amp;range_fl);
    range_pub_fr-&gt;publish(&amp;range_fr);
    range_pub_rl-&gt;publish(&amp;range_rl);
    range_pub_rr-&gt;publish(&amp;range_rr);
}
</code></pre>
<p>Whole file should look like this:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"hFramework.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"hCloudClient.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"ros.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"geometry_msgs/Twist.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"geometry_msgs/PoseStamped.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sensor_msgs/BatteryState.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"std_msgs/Bool.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sensor_msgs/Range.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"tf/tf.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"ROSbot.h"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> hFramework;

<span class="hljs-comment">// Uncomment one of these lines, accordingly to range sensor type of your ROSbot</span>
<span class="hljs-comment">// If you have version with infared sensor:</span>
<span class="hljs-comment">// static const SensorType sensor_type = SENSOR_INFRARED;</span>
<span class="hljs-comment">// If you have version with laser sensor:</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> SensorType sensor_type = SENSOR_LASER;
<span class="hljs-comment">// If you want to use your own sensor:</span>
<span class="hljs-comment">// static const SensorType sensor_type = NO_DISTANCE_SENSOR;</span>

<span class="hljs-comment">// Uncomment one of these lines, accordingly to IMU sensor type of your device</span>
<span class="hljs-comment">// If you have version with MPU9250:</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> ImuType imu_type = MPU9250;
<span class="hljs-comment">// If you want to use your own sensor:</span>
<span class="hljs-comment">// static const ImuType imu_type = NO_IMU;</span>

ros::NodeHandle nh;
sensor_msgs::BatteryState battery;
ros::Publisher *battery_pub;
geometry_msgs::PoseStamped pose;
ros::Publisher *pose_pub;

sensor_msgs::Range range_fl;
sensor_msgs::Range range_fr;
sensor_msgs::Range range_rl;
sensor_msgs::Range range_rr;

ros::Publisher *range_pub_fl;
ros::Publisher *range_pub_fr;
ros::Publisher *range_pub_rl;
ros::Publisher *range_pub_rr;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; rosbot_pose;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; rpy;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; ranges;

<span class="hljs-keyword">int</span> publish_counter = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">twistCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> geometry_msgs::Twist &amp;twist)</span>
</span>{
    rosbot.setSpeed(twist.linear.x, twist.angular.z);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initCmdVelSubscriber</span><span class="hljs-params">()</span>
</span>{
    ros::Subscriber&lt;geometry_msgs::Twist&gt; *cmd_sub = <span class="hljs-keyword">new</span> ros::Subscriber&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">"/cmd_vel"</span>, &amp;twistCallback);
    nh.subscribe(*cmd_sub);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std_msgs::Bool &amp;msg)</span>
</span>{
    <span class="hljs-keyword">if</span> (msg.data == <span class="hljs-literal">true</span>)
    {
        rosbot.reset_odometry();
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initResetOdomSubscriber</span><span class="hljs-params">()</span>
</span>{
    ros::Subscriber&lt;std_msgs::Bool&gt; *odom_reset_sub = <span class="hljs-keyword">new</span> ros::Subscriber&lt;std_msgs::Bool&gt;(<span class="hljs-string">"/reset_odom"</span>, &amp;resetCallback);
    nh.subscribe(*odom_reset_sub);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initDistanceSensorsPublisher</span><span class="hljs-params">()</span>
</span>{
    range_fl.header.frame_id = <span class="hljs-string">"range_fl"</span>;
    range_fr.header.frame_id = <span class="hljs-string">"range_fr"</span>;
    range_rl.header.frame_id = <span class="hljs-string">"range_rl"</span>;
    range_rr.header.frame_id = <span class="hljs-string">"range_rr"</span>;

    <span class="hljs-keyword">switch</span> (sensor_type)
    {
    <span class="hljs-keyword">case</span> SENSOR_LASER:
        range_fl.field_of_view = <span class="hljs-number">0.26</span>;
        range_fl.min_range = <span class="hljs-number">0.03</span>;
        range_fl.max_range = <span class="hljs-number">0.90</span>;

        range_fr.field_of_view = <span class="hljs-number">0.26</span>;
        range_fr.min_range = <span class="hljs-number">0.03</span>;
        range_fr.max_range = <span class="hljs-number">0.90</span>;

        range_rl.field_of_view = <span class="hljs-number">0.26</span>;
        range_rl.min_range = <span class="hljs-number">0.03</span>;
        range_rl.max_range = <span class="hljs-number">0.90</span>;

        range_rr.field_of_view = <span class="hljs-number">0.26</span>;
        range_rr.min_range = <span class="hljs-number">0.03</span>;
        range_rr.max_range = <span class="hljs-number">0.90</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> SENSOR_INFRARED:
        range_fl.radiation_type = sensor_msgs::Range::INFRARED;
        range_fl.field_of_view = <span class="hljs-number">0.26</span>;
        range_fl.min_range = <span class="hljs-number">0.05</span>;
        range_fl.max_range = <span class="hljs-number">0.299</span>;

        range_fr.radiation_type = sensor_msgs::Range::INFRARED;
        range_fr.field_of_view = <span class="hljs-number">0.26</span>;
        range_fr.min_range = <span class="hljs-number">0.05</span>;
        range_fr.max_range = <span class="hljs-number">0.299</span>;

        range_rl.radiation_type = sensor_msgs::Range::INFRARED;
        range_rl.field_of_view = <span class="hljs-number">0.26</span>;
        range_rl.min_range = <span class="hljs-number">0.05</span>;
        range_rl.max_range = <span class="hljs-number">0.299</span>;

        range_rr.radiation_type = sensor_msgs::Range::INFRARED;
        range_rr.field_of_view = <span class="hljs-number">0.26</span>;
        range_rr.min_range = <span class="hljs-number">0.05</span>;
        range_rr.max_range = <span class="hljs-number">0.299</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NO_DISTANCE_SENSOR:
        <span class="hljs-comment">// Do your own implementation</span>
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (sensor_type != SensorType::NO_DISTANCE_SENSOR)
    {
        range_pub_fl = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/fl"</span>, &amp;range_fl);
        range_pub_fr = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/fr"</span>, &amp;range_fr);
        range_pub_rl = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/rl"</span>, &amp;range_rl);
        range_pub_rr = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/range/rr"</span>, &amp;range_rr);
        nh.advertise(*range_pub_fl);
        nh.advertise(*range_pub_fr);
        nh.advertise(*range_pub_rl);
        nh.advertise(*range_pub_rr);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initBatteryPublisher</span><span class="hljs-params">()</span>
</span>{
    battery_pub = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/battery"</span>, &amp;battery);
    nh.advertise(*battery_pub);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initPosePublisher</span><span class="hljs-params">()</span>
</span>{
    pose.header.frame_id = <span class="hljs-string">"base_link"</span>;
    pose.pose.orientation = tf::createQuaternionFromYaw(<span class="hljs-number">0</span>);
    pose_pub = <span class="hljs-keyword">new</span> ros::Publisher(<span class="hljs-string">"/pose"</span>, &amp;pose);
    nh.advertise(*pose_pub);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hMain</span><span class="hljs-params">()</span>
</span>{
    Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">"init ROSbot\n"</span>);
    rosbot.initROSbot(sensor_type);
    Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">"init with dvice\n"</span>);
    platform.begin(&amp;RPi);
    nh.getHardware()-&gt;initWithDevice(&amp;platform.LocalSerial);
    nh.initNode();

    initBatteryPublisher();
    initPosePublisher();
    initDistanceSensorsPublisher();
    initCmdVelSubscriber();
    initResetOdomSubscriber();

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        nh.spinOnce();
        publish_counter++;
        <span class="hljs-keyword">if</span> (publish_counter &gt; <span class="hljs-number">10</span>)
        {
            <span class="hljs-comment">// get ROSbot pose</span>
            rosbot_pose = rosbot.getPose();
            pose.pose.position.x = rosbot_pose[<span class="hljs-number">0</span>];
            pose.pose.position.y = rosbot_pose[<span class="hljs-number">1</span>];
            pose.pose.orientation = tf::createQuaternionFromYaw(rosbot_pose[<span class="hljs-number">2</span>]);
            <span class="hljs-comment">// publish pose</span>
            pose_pub-&gt;publish(&amp;pose);

            <span class="hljs-keyword">if</span> (sensor_type != SensorType::NO_DISTANCE_SENSOR)
            {
                <span class="hljs-comment">// get ranges from distance sensors</span>
                ranges = rosbot.getRanges(sensor_type);
                range_fl.range = ranges[<span class="hljs-number">0</span>];
                range_fr.range = ranges[<span class="hljs-number">1</span>];
                range_rl.range = ranges[<span class="hljs-number">2</span>];
                range_rr.range = ranges[<span class="hljs-number">3</span>];
                Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Ranges %f %f %f %f\n"</span>, ranges[<span class="hljs-number">0</span>], ranges[<span class="hljs-number">1</span>], ranges[<span class="hljs-number">2</span>], ranges[<span class="hljs-number">3</span>]);
                <span class="hljs-comment">// publish ranges</span>
                range_pub_fl-&gt;publish(&amp;range_fl);
                range_pub_fr-&gt;publish(&amp;range_fr);
                range_pub_rl-&gt;publish(&amp;range_rl);
                range_pub_rr-&gt;publish(&amp;range_rr);
            }

            <span class="hljs-comment">// get battery voltage</span>
            battery.voltage = rosbot.getBatteryLevel();
            <span class="hljs-comment">// publish battery voltage</span>
            battery_pub-&gt;publish(&amp;battery);
            publish_counter = <span class="hljs-number">0</span>;
        }
        sys.delay(<span class="hljs-number">10</span>);
    }
}
</code></pre>
<p>Build the project and upload it to your device. Then open <code>action_controller.cpp</code>
file in text editor.</p>
<p>Begin with including required header file:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Range.h&gt;</span></span>
</code></pre>
<p>Add variables for measured object distance, average distance and desired
distance to obstacle:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">float</span> distFL = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> distFR = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> average_dist = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> desired_dist = <span class="hljs-number">0.2</span>;
</code></pre>
<p>Callback functions for incoming sensor messages, their task is only to
put values into appropriate variables:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">distFL_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::Range &amp;range)</span> </span>{
       distFL = range.range;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">distFR_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::Range &amp;range)</span> </span>{
       distFR = range.range;
    }
</code></pre>
<p>Then, in <code>switch</code> statement, calculate average distance and set velocity
proportional to it only if both sensors found an obstacle, else set zero
value for linear velocity:</p>
<pre><code class="hljs css language-cpp">    <span class="hljs-keyword">if</span> (distFL &gt; <span class="hljs-number">0</span> &amp;&amp; distFR &gt; <span class="hljs-number">0</span>) {
        average_dist = (distFL + distFR) / <span class="hljs-number">2</span>;
        set_vel.linear.x = (average_dist - desired_dist) /<span class="hljs-number">4</span>;
    }
    <span class="hljs-keyword">else</span> {
        set_vel.linear.x = <span class="hljs-number">0</span>;
    }
</code></pre>
<p>In main function, subscribe to sensor topics:</p>
<pre><code class="hljs css language-cpp">    ros::Subscriber distFL_sub = n.subscribe(<span class="hljs-string">"/range/fl"</span>, <span class="hljs-number">1</span>, distFL_callback);
    ros::Subscriber distFR_sub = n.subscribe(<span class="hljs-string">"/range/fr"</span>, <span class="hljs-number">1</span>, distFR_callback);
</code></pre>
<p>Final file should look like this:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ros/ros.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/Float32MultiArray.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/Int32MultiArray.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;std_msgs/String.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sensor_msgs/Range.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMILE 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_LEFT 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_UP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARROW_DOWN 6</span>
<span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
ros::Publisher action_pub;
geometry_msgs::Twist set_vel;
<span class="hljs-keyword">int</span> camera_center = <span class="hljs-number">320</span>; <span class="hljs-comment">// left 0, right 640</span>
<span class="hljs-keyword">float</span> max_ang_vel = <span class="hljs-number">0.6</span>;
<span class="hljs-keyword">float</span> min_ang_vel = <span class="hljs-number">0.4</span>;
<span class="hljs-keyword">float</span> ang_vel = <span class="hljs-number">0</span>;

<span class="hljs-keyword">float</span> distFL = <span class="hljs-number">0</span>;
<span class="hljs-keyword">float</span> distFR = <span class="hljs-number">0</span>;
<span class="hljs-keyword">float</span> average_dist = <span class="hljs-number">0</span>;
<span class="hljs-keyword">float</span> desired_dist = <span class="hljs-number">0.2</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">distFL_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::Range &amp;range)</span> </span>{
   distFL = range.range;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">distFR_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sensor_msgs::Range &amp;range)</span> </span>{
   distFR = range.range;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objectCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std_msgs::Float32MultiArrayPtr &amp;object)</span> </span>{
   <span class="hljs-keyword">if</span> (object-&gt;data.size() &gt; <span class="hljs-number">0</span>) {
      id = object-&gt;data[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">float</span> objectWidth = object-&gt;data[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">float</span> objectHeight = object-&gt;data[<span class="hljs-number">2</span>];
      <span class="hljs-keyword">float</span> x_pos;
      <span class="hljs-keyword">float</span> speed_coefficient = (<span class="hljs-keyword">float</span>) camera_center / max_ang_vel;

      <span class="hljs-comment">// Find corners OpenCV</span>
      cv::<span class="hljs-function">Mat <span class="hljs-title">cvHomography</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32F)</span></span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;cv::Point2f&gt; inPts, outPts;
      <span class="hljs-keyword">switch</span> (id) {
         <span class="hljs-keyword">case</span> ARROW_LEFT:
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_UP:
            set_vel.linear.x = <span class="hljs-number">1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> ARROW_DOWN:
            set_vel.linear.x = <span class="hljs-number">-1</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> SMILE:
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">3</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">4</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = object-&gt;data[<span class="hljs-number">5</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">6</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">7</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = object-&gt;data[<span class="hljs-number">8</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">9</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">10</span>];
            cvHomography.at&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = object-&gt;data[<span class="hljs-number">11</span>];

            inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
            inPts.push_back(cv::Point2f(objectWidth, <span class="hljs-number">0</span>));
            inPts.push_back(cv::Point2f(<span class="hljs-number">0</span>, objectHeight));
            inPts.push_back(cv::Point2f(objectWidth, objectHeight));
            cv::perspectiveTransform(inPts, outPts, cvHomography);

            x_pos = (<span class="hljs-keyword">int</span>) (outPts.at(<span class="hljs-number">0</span>).x + outPts.at(<span class="hljs-number">1</span>).x + outPts.at(<span class="hljs-number">2</span>).x +
            outPts.at(<span class="hljs-number">3</span>).x) / <span class="hljs-number">4</span>;
            ang_vel = -(x_pos - camera_center) / speed_coefficient;
            
            <span class="hljs-keyword">if</span> (ang_vel &gt;= -(min_ang_vel/<span class="hljs-number">2</span>) &amp;&amp; ang_vel &lt;= (min_ang_vel/<span class="hljs-number">2</span>)){
                set_vel.angular.z = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">if</span> (distFL &gt; <span class="hljs-number">0</span> &amp;&amp; distFR &gt; <span class="hljs-number">0</span>) {
                        average_dist = (distFL + distFR) / <span class="hljs-number">2</span>;
                        set_vel.linear.x = (average_dist - desired_dist) /<span class="hljs-number">4</span>;
                    }
                    <span class="hljs-keyword">else</span> {
                        set_vel.linear.x = <span class="hljs-number">0</span>;
                    }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &gt;=max_ang_vel){
        set_vel.angular.z = max_ang_vel;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ang_vel &lt;=-max_ang_vel){
        set_vel.angular.z = -max_ang_vel;
        }
        <span class="hljs-keyword">else</span> {
        set_vel.angular.z = ang_vel;
        }

            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>: <span class="hljs-comment">// other object</span>
            set_vel.linear.x = <span class="hljs-number">0</span>;
            set_vel.angular.z = <span class="hljs-number">0</span>;
      }
      action_pub.publish(set_vel);
   } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// No object detected</span>
      set_vel.linear.x = <span class="hljs-number">0</span>;
      set_vel.angular.z = <span class="hljs-number">0</span>;
      action_pub.publish(set_vel);
   }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{

   std_msgs::String s;
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str;
   str.clear();
   str.append(<span class="hljs-string">""</span>);
   <span class="hljs-built_in">std</span>::to_string(<span class="hljs-number">3</span>);
   s.data = str;
   ros::init(argc, argv, <span class="hljs-string">"action_controller"</span>);
   ros::<span class="hljs-function">NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">"~"</span>)</span></span>;
   ros::Subscriber sub = n.subscribe(<span class="hljs-string">"/objects"</span>, <span class="hljs-number">1</span>, objectCallback);

   ros::Subscriber distL_sub = n.subscribe(<span class="hljs-string">"/range/fl"</span>, <span class="hljs-number">1</span>, distFL_callback);
   ros::Subscriber distR_sub = n.subscribe(<span class="hljs-string">"/range/fr"</span>, <span class="hljs-number">1</span>, distFR_callback);
   ros::<span class="hljs-function">Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;
   action_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">"/cmd_vel"</span>, <span class="hljs-number">1</span>);
   set_vel.linear.x = <span class="hljs-number">0</span>;
   set_vel.linear.y = <span class="hljs-number">0</span>;
   set_vel.linear.z = <span class="hljs-number">0</span>;
   set_vel.angular.x = <span class="hljs-number">0</span>;
   set_vel.angular.y = <span class="hljs-number">0</span>;
   set_vel.angular.z = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (ros::ok()) {
      ros::spinOnce();
      loop_rate.sleep();
   }
}
</code></pre>
<p>Now you can build your node and test it.</p>
<p><strong>Task 3</strong> Run your node along with <code>find_object_2d</code> and <code>astra.launch</code> or <strong>Gazebo</strong> simulator.
Place the same object as in Task 2 in front of your robot.
Observe how it turns and drives towards the object.</p>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p>After completing this tutorial you should be able to configure your
CORE2 device with vision system to recognize objects. You should also be
able to determine the position of recognized object relative to camera and
create a node that perform specific action related to recognized objects.
You should also know how to handle proximity sensors with <code>sensor_msgs/Range</code>
message type.</p>
<hr>
<p><em>by Łukasz Mitka, Husarion</em></p>
<p><em>Do you need any support with completing this tutorial or have any difficulties with software or hardware? Feel free to describe your thoughts on our community forum: <a href="https://community.husarion.com/">https://community.husarion.com/</a> or to contact with our support: <a href="mailto:support@husarion.com">support@husarion.com</a></em></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/3-simple-kinematics-for-mobile-robot"><span class="arrow-prev">← </span><span>3. Simple kinematics for mobile robot</span></a><a class="docs-next button" href="/docusaurus-husarion-docs/docs/tutorials/ros-tutorials/5-running-ros-on-multiple-machines"><span>5. Running ROS on multiple machines</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a></li><li><a href="#teaching-objects">Teaching objects</a></li><li><a href="#recognizing-objects">Recognizing objects</a></li><li><a href="#making-decision-with-recognized-object">Making decision with recognized object</a></li><li><a href="#getting-position-of-recognized-object">Getting position of recognized object</a></li><li><a href="#following-the-object">Following the object</a></li><li><a href="#summary">Summary</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docusaurus-husarion-docs/" class="nav-home"></a><div><h5>Company</h5><a href="https://husarion.com/about.html" target="_blank" rel="noreferrer noopener">About Us</a><a href="https://husarion.com/contact.html" target="_blank" rel="noreferrer noopener">Contact</a><a href="https://medium.com/husarion-blog" target="_blank" rel="noreferrer noopener">Blog</a><a href="https://cloud.husarion.com/tos" target="_blank" rel="noreferrer noopener">Terms of service</a></div><div><h5>Developers</h5><a href="#" target="_blank" rel="noreferrer noopener">Documentation</a><a href="https://cloud.husarion.com/" target="_blank" rel="noreferrer noopener">Husarion Cloud</a><a href="https://community.husarion.com/" target="_blank" rel="noreferrer noopener">Community forum</a><a href="https://husarion.com/downloads/" target="_blank" rel="noreferrer noopener">Downloads</a><a href="https://husarion.com" target="_blank" rel="noreferrer noopener">Home Page</a></div><div><h5>Social</h5><a href="https://www.facebook.com/husarionTechnology/" target="_blank" rel="noreferrer noopener">Facebook</a><a href="https://twitter.com/husarion" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://github.com/husarion" target="_blank" rel="noreferrer noopener">GitHub</a></div></section><section class="copyright">Copyright © 2019 Husarion sp. z o.o.</section></footer></div></body></html>